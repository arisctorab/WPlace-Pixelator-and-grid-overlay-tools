<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Pixel Art Converter — Standalone</title>
  <style>
    :root{--bg:#0f1724;--panel:#1f2937;--muted:#9ca3af;--accent:#06b6d4}
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;font-family:Inter,Segoe UI,Roboto,system-ui,-apple-system,"Helvetica Neue",Arial;background:linear-gradient(180deg,#071029 0%, #071b2b 100%);color:#e6eef6}
    .app{display:grid;grid-template-columns:360px 1fr;gap:18px;padding:20px;min-height:100vh}
    .panel{background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(255,255,255,0.01));padding:18px;border-radius:12px;box-shadow:0 6px 18px rgba(2,6,23,0.6)}
    h1{margin:0 0 8px;font-size:18px}
    label{display:block;margin-top:10px;color:var(--muted);font-size:13px}
    .row{display:flex;gap:8px;align-items:center}
    input[type=number]{padding:6px;border-radius:6px;border:1px solid rgba(255,255,255,0.03);background:transparent;color:inherit}
    input[type=color]{width:44px;height:36px;border:0;padding:0;background:transparent}
    .btn{background:var(--accent);color:#042027;padding:8px 10px;border-radius:8px;border:0;cursor:pointer;font-weight:600}
    .btn.secondary{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted)}
    .palette{display:flex;flex-wrap:wrap;gap:8px;margin-top:8px}
    .swatch{width:40px;height:28px;border-radius:6px;position:relative;cursor:pointer;border:2px solid rgba(255,255,255,0.03);display:flex;align-items:center;justify-content:center;font-size:11px}
    .swatch button.remove{position:absolute;top:-8px;right:-8px;background:#111;padding:2px 6px;border-radius:10px;font-size:11px;border:1px solid rgba(255,255,255,0.06);color:var(--muted);cursor:pointer}
    .tiny{font-size:12px;color:var(--muted)}
    .preview{display:flex;align-items:center;justify-content:center}
    canvas{background:#0b1220;border-radius:8px;image-rendering:pixelated;max-width:100%;height:auto}
    .controls{display:flex;gap:8px;align-items:center}
    footer{margin-top:12px;display:flex;justify-content:flex-end}
    @media(max-width:980px){.app{grid-template-columns:1fr}}
  </style>
</head>
<body>
  <div class="app">
    <div class="panel">
      <h1>Pixel Art Converter</h1>
      <div class="tiny">Upload an image, set the target (pixel) resolution, choose a scale multiplier, and manage a color palette (or load one from a text file — one hex per line).</div>

      <label for="file">Image</label>
      <input id="file" type="file" accept="image/*">

      <label for="outWidth">Target resolution (the pixelated image size)</label>
      <div class="row">
        <input id="outWidth" type="number" min="1" value="64" style="width:100px"> ×
        <input id="outHeight" type="number" min="1" value="64" style="width:100px">
      </div>

      <label for="scale">Scale multiplier (display & output scale)</label>
      <div class="row">
        <input id="scale" type="range" min="1" max="8" value="1">
        <div class="tiny">× <span id="scaleVal">1</span></div>
      </div>

      <label>Palette</label>
      <div class="row">
        <input id="paletteColor" type="color" value="#ffcc00">
        <button id="addColor" class="btn secondary">Add</button>
        <button id="resetPalette" class="btn secondary">Reset</button>
      </div>

      <div class="row" style="margin-top:6px">
        <input id="paletteFile" type="file" accept="text/plain">
        <button id="loadPalette" class="btn secondary">Load Palette</button>
      </div>

      <div class="palette" id="palette"></div>

      <label class="tiny" style="margin-top:10px"><input id="usePaletteOnly" type="checkbox" checked> Force palette colors (replace with nearest palette color)</label>

      <footer>
        <button id="download" class="btn">Download PNG</button>
      </footer>
    </div>

    <div class="panel preview">
      <div style="width:100%;display:flex;flex-direction:column;gap:8px;align-items:center;">
        <canvas id="outCanvas" width="640" height="360"></canvas>
        <div class="tiny" id="infoText">Output: - × -</div>
      </div>
    </div>
  </div>

  <script>
    // Elements
    const fileInput = document.getElementById('file');
    const outWidthInput = document.getElementById('outWidth');
    const outHeightInput = document.getElementById('outHeight');
    const scaleInput = document.getElementById('scale');
    const scaleVal = document.getElementById('scaleVal');
    const paletteDiv = document.getElementById('palette');
    const colorPicker = document.getElementById('paletteColor');
    const addColorBtn = document.getElementById('addColor');
    const resetPaletteBtn = document.getElementById('resetPalette');
    const loadPaletteBtn = document.getElementById('loadPalette');
    const paletteFileInput = document.getElementById('paletteFile');
    const outCanvas = document.getElementById('outCanvas');
    const downloadBtn = document.getElementById('download');
    const infoText = document.getElementById('infoText');
    const usePaletteOnlyCheckbox = document.getElementById('usePaletteOnly');

    // Basic palette
    let palette = ['#000000','#ffffff','#ff0000','#00ff00','#0000ff','#ffcc00','#ff66cc','#66ffff'];

    // Offscreen canvas used for the small pixel grid
    const smallCanvas = document.createElement('canvas');
    const smallCtx = smallCanvas.getContext('2d');

    // Image
    const img = new Image();
    let imgLoaded = false;

    // ---- Palette rendering / management ----
    function normalizeHex(h){
      if(!h) return '#000000';
      h = h.trim();
      if(h[0] !== '#') h = '#'+h;
      if(h.length === 4) { // #rgb -> #rrggbb
        h = '#'+h[1]+h[1]+h[2]+h[2]+h[3]+h[3];
      }
      return h.substring(0,7);
    }

    function renderPalette(){
      paletteDiv.innerHTML = '';
      palette = palette.map(normalizeHex);
      palette.forEach((c,i)=>{
        const sw = document.createElement('div');
        sw.className = 'swatch';
        sw.style.background = c;
        sw.title = c;

        // remove button
        const remove = document.createElement('button');
        remove.className = 'remove';
        remove.textContent = '×';
        remove.addEventListener('click', e => { e.stopPropagation(); palette.splice(i,1); renderPalette(); process(); });

        // clicking a swatch sets the color picker
        sw.addEventListener('click', ()=>{ colorPicker.value = normalizeHex(c); });

        sw.appendChild(remove);
        paletteDiv.appendChild(sw);
      });
    }

    addColorBtn.addEventListener('click', ()=>{ palette.push(normalizeHex(colorPicker.value)); renderPalette(); process(); });
    resetPaletteBtn.addEventListener('click', ()=>{ palette = ['#000000','#ffffff','#ff0000','#00ff00','#0000ff','#ffcc00','#ff66cc','#66ffff']; renderPalette(); process(); });

    loadPaletteBtn.addEventListener('click', ()=>{
      const file = paletteFileInput.files[0];
      if(!file) return;
      const reader = new FileReader();
      reader.onload = e => {
        const lines = e.target.result.split(/\r?\n/)
          .map(l=>l.trim())
          .filter(l=>/^#?[0-9a-fA-F]{3}$/.test(l) || /^#?[0-9a-fA-F]{6}$/.test(l));
        if(lines.length){
          palette = lines.map(normalizeHex);
          renderPalette();
          process();
        } else {
          alert('No valid hex colors found in the file. Use one hex color per line (e.g. #ffcc00).');
        }
      };
      reader.readAsText(file);
    });

    // ---- Color conversion: RGB -> CIE Lab (for perceptual distance) ----
    function hexToRgb(hex){ const h = hex.replace('#',''); return {r:parseInt(h.substring(0,2),16), g:parseInt(h.substring(2,4),16), b:parseInt(h.substring(4,6),16)}; }

    function srgbToLinear(v){ v = v / 255; return v <= 0.04045 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4); }
    function rgbToXyz({r,g,b}){
      const R = srgbToLinear(r);
      const G = srgbToLinear(g);
      const B = srgbToLinear(b);
      // Observer = 2°, Illuminant = D65
      const X = R*0.4124564 + G*0.3575761 + B*0.1804375;
      const Y = R*0.2126729 + G*0.7151522 + B*0.0721750;
      const Z = R*0.0193339 + G*0.1191920 + B*0.9503041;
      return {X: X*100, Y: Y*100, Z: Z*100};
    }
    function xyzToLab({X,Y,Z}){
      // D65 reference white
      const refX = 95.047, refY = 100.000, refZ = 108.883;
      let x = X / refX, y = Y / refY, z = Z / refZ;
      function f(t){ return t > 0.008856 ? Math.cbrt(t) : (7.787 * t) + (16/116); }
      const fx = f(x), fy = f(y), fz = f(z);
      const L = (116 * fy) - 16;
      const a = 500 * (fx - fy);
      const b = 200 * (fy - fz);
      return {L,a,b};
    }
    function rgbToLab(rgb){ return xyzToLab(rgbToXyz(rgb)); }

    // cache palette Lab values for faster nearest searches
    let paletteLab = null;
    function rebuildPaletteLab(){ paletteLab = palette.map(h => rgbToLab(hexToRgb(h))); }

    function labDistanceSq(a,b){ const dL = a.L - b.L; const da = a.a - b.a; const db = a.b - b.b; return dL*dL + da*da + db*db; }

    function findNearestColorLab(r,g,b){
      if(!palette.length) return {r,g,b};
      if(!paletteLab) rebuildPaletteLab();
      const lab = rgbToLab({r,g,b});
      let bestIdx = 0, bestDist = Infinity;
      for(let i=0;i<paletteLab.length;i++){
        const d = labDistanceSq(lab, paletteLab[i]);
        if(d < bestDist){ bestDist = d; bestIdx = i; }
      }
      return hexToRgb(palette[bestIdx]);
    }

    // ---- Processing pipeline ----
    function clampByte(v){ return Math.max(0, Math.min(255, Math.round(v))); }

    function process(){
      if(!imgLoaded) return;

      const smallW = Math.max(1, Number(outWidthInput.value));
      const smallH = Math.max(1, Number(outHeightInput.value));
      const scale = Math.max(1, Number(scaleInput.value));

      // downscale the source into the small canvas
      smallCanvas.width = smallW;
      smallCanvas.height = smallH;
      // draw the image scaled into the small canvas (this pixelates)
      smallCtx.clearRect(0,0,smallW,smallH);
      smallCtx.drawImage(img, 0, 0, smallW, smallH);

      // get pixels and replace with nearest palette colors (Lab distance)
      const imageData = smallCtx.getImageData(0,0,smallW,smallH);
      const data = imageData.data;

      if(usePaletteOnlyCheckbox.checked){
        rebuildPaletteLab();
        for(let i=0;i<data.length;i+=4){
          const r = data[i], g = data[i+1], b = data[i+2];
          const nearest = findNearestColorLab(r,g,b);
          data[i] = nearest.r; data[i+1] = nearest.g; data[i+2] = nearest.b;
        }
        smallCtx.putImageData(imageData, 0, 0);
      }

      // upscale to output canvas using integer multiplier to avoid stretching artifacts
      const destW = smallW * scale;
      const destH = smallH * scale;

      // safety clamp to avoid extremely large canvases
      const MAX_DIM = 4096;
      if(destW > MAX_DIM || destH > MAX_DIM){
        console.warn('Requested output is large — clamping to', MAX_DIM);
      }

      outCanvas.width = Math.min(destW, MAX_DIM);
      outCanvas.height = Math.min(destH, MAX_DIM);

      const ctx = outCanvas.getContext('2d');
      ctx.imageSmoothingEnabled = false;
      ctx.clearRect(0,0,outCanvas.width,outCanvas.height);
      ctx.drawImage(smallCanvas, 0, 0, outCanvas.width, outCanvas.height);

      infoText.textContent = `Output: ${smallW}×${smallH} → ${outCanvas.width}×${outCanvas.height} (scale ×${scale})`;
    }

    // ---- Events ----
    fileInput.addEventListener('change', e => {
      const f = e.target.files && e.target.files[0];
      if(!f) return;
      const url = URL.createObjectURL(f);
      img.onload = () => {
        imgLoaded = true;
        // optional: set default target resolution to a reasonable size based on image
        // keep user's current values but do not force change
        process();
        URL.revokeObjectURL(url);
      };
      img.src = url;
    });

    outWidthInput.addEventListener('input', process);
    outHeightInput.addEventListener('input', process);
    scaleInput.addEventListener('input', ()=>{ scaleVal.textContent = scaleInput.value; process(); });
    usePaletteOnlyCheckbox.addEventListener('change', process);

    downloadBtn.addEventListener('click', ()=>{
      // Trigger download of current canvas (already at scaled resolution)
      const link = document.createElement('a');
      link.href = outCanvas.toDataURL('image/png');
      link.download = `pixelart_${outCanvas.width}x${outCanvas.height}.png`;
      link.click();
    });

    // initialize
    renderPalette();
    scaleVal.textContent = scaleInput.value;
  </script>
</body>
</html>
